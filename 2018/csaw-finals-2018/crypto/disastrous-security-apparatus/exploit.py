#!/usr/bin/env python3

import requests as rq 
import random
import binascii
import hashlib
import json
import os
import random
import struct
import gmpy2

from cryptography.exceptions import InvalidSignature
from cryptography.fernet import Fernet, InvalidToken
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric.rsa import _modinv
from cryptography.hazmat.primitives.serialization import load_pem_private_key

from Cryptodome.PublicKey import DSA

from randcrack import RandCrack

url = "http://216.165.2.36:1000/"

def getrand64():
	temp = rq.get(url+"forgotpass").text.split("/")[-1]
	return struct.unpack(">Q",binascii.unhexlify(temp))[0]

def public_key():
	return json.loads(rq.get(url+"public_key").text)

def sign():
	return json.loads(rq.get(url+"sign/AAAA").text)	

def getx(pk):
	h = hashlib.sha1("AAAA".encode("ascii")).digest()
	h = int.from_bytes(h, "big")
	g=pk['g']
	q=pk['q']
	p=pk['p']
	sig = sign()
	s=sig['s']
	r=sig['r']
	k=rc.predict_randrange(2,q)
	x=int((s*k-h)*gmpy2.invert(r,q) % q)
	return x

def challenge():
	return rq.get(url+"challenge").text

print (getrand64())

rc = RandCrack()

for i in range(624//2):
	print (i)
	temp = getrand64()
	rc.submit(temp&0xffffffff)
	rc.submit(temp>>32)

pk = public_key()
g=pk['g']
q=pk['q']
p=pk['p']

x=getx(pk) #x=71178243551132085537949605121638345878505890738853859397039273179291690262554
y=pow(g,x,p)

assert y==pk['y']

key = DSA.construct((y,g,p,q,x))
pem_data=(key.exportKey())
ctf_key = load_pem_private_key(
    pem_data, password=None, backend=default_backend()
)

data = challenge().encode("ascii")
sig = binascii.hexlify(ctf_key.sign(data,hashes.SHA256()))

print (sig,data)
print (rq.post(url+"capture",data={"signature":sig,"challenge":data}).text)